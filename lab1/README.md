# ЛАБОРАТОРНАЯ РАБОТА 1

## Задание

По имеющейся **SRS** требуется определить:

- **Завершимость**.
- **Конечность классов эквивалентности по НФ**
  (для эквивалентностей считаем, что правила применяются **в обе стороны**).
  Если классов конечное число — построить **минимальную** систему переписывания, им соответствующую.
- **Локальную конфлюэнтность** и **пополняемость по Кнуту–Бендиксу**.

---

## Исходная система правил (SRS)

```text
bbb → bab
abab → bab
abba → aba
babb → abb
bbab → bab
aaaaa → a
aaaba → bba
aaaabb → bb
abb → abaaaa
abaaab → ab
baaaab → bab
baaabb → ε
bbaaaa → bb
bbaaab → aaaab
baabaab → baaab
babaaba → bab
babaabb → babaaa
```

---

## 1) Система завершима (терминируема).

Введём функцию от слова $w$:

$F(w) = (S_b(w), S_a(w))$

где:

$S_b(w) = \sum {i \mid w[i] = \texttt{b}}$ — сумма позиций всех символов 'b' в строке (позиции нумеруются с 1)

$S_a(w) = \sum {i \mid w[i] = \texttt{a}}$ — сумма позиций всех символов 'a' в строке

Если символа 'b' нет в строке, то $S_b(w) = 0$. Аналогично для 'a'.

Сравнение происходит лексикографически: сначала по $S_b(w)$, затем по $S_a(w)$.

---

### **Анализ правил:**

Случай 1: $S_b(l) > S_b(r)$

- $\texttt{bbb} \to \texttt{bab}$: $S_b(\texttt{bbb}) = 1+2+3 = 6$, $S_b(\texttt{bab}) = 1+3 = 4$ ⇒ уменьшается
- $\texttt{abab} \to \texttt{bab}$: $S_b(\texttt{abab}) = 2+4 = 6$, $S_b(\texttt{bab}) = 1+3 = 4$ ⇒ уменьшается
- $\texttt{abba} \to \texttt{aba}$: $S_b(\texttt{abba}) = 2+3 = 5$, $S_b(\texttt{aba}) = 2$ ⇒ уменьшается
- $\texttt{babb} \to \texttt{abb}$: $S_b(\texttt{babb}) = 1+3+4 = 8$, $S_b(\texttt{abb}) = 2+3 = 5$ ⇒ уменьшается
- $\texttt{bbab} \to \texttt{bab}$: $S_b(\texttt{bbab}) = 1+2+4 = 7$, $S_b(\texttt{bab}) = 1+3 = 4$ ⇒ уменьшается
- $\texttt{aaaba} \to \texttt{bba}$: $S_b(\texttt{aaaba}) = 4$, $S_b(\texttt{bba}) = 1+2 = 3$ ⇒ уменьшается
- $\texttt{aaaabb} \to \texttt{bb}$: $S_b(\texttt{aaaabb}) = 5+6 =11$, $S_b(\texttt{bb}) = 1+2 = 3$ ⇒ уменьшается
- $\texttt{abb} \to \texttt{abaaaa}$: $S_b(\texttt{abb}) = 2+3 = 5$, $S_b(\texttt{abaaaa}) = 2$ ⇒ уменьшается
- $\texttt{abaaab} \to \texttt{ab}$: $S_b(\texttt{abaaab}) = 2+6 = 8$, $S_b(\texttt{ab}) = 2$ ⇒ уменьшается
- $\texttt{baaaab} \to \texttt{bab}$: $S_b(\texttt{baaaab}) = 1+6 = 7$, $S_b(\texttt{bab}) = 1+3 = 4$ ⇒ уменьшается
- $\texttt{baaabb} \to \varepsilon$: $S_b(\texttt{baaabb}) = 1+6 = 7$, $S_b(\texttt{0}) = 0$ ⇒ уменьшается
- $\texttt{bbaaab} \to \texttt{aaaab}$: $S_b(\texttt{bbaaab}) = 1+2+6 = 9$, $S_b(\texttt{aaaab}) = 5$ ⇒ уменьшается
- $\texttt{baabaab} \to \texttt{baaab}$: $S_b(\texttt{baabaab}) = 1+4+7 = 12$, $S_b(\texttt{baaab}) = 1+5 = 6$ ⇒ уменьшается
- $\texttt{babaaba} \to \texttt{bab}$: $S_b(\texttt{babaaba}) = 1+3+6 = 9$, $S_b(\texttt{bab}) = 1+3 = 4$ ⇒ уменьшается
- $\texttt{babaabb} \to \texttt{babaaa}$: $S_b(\texttt{babaabb}) = 1+3+6+7 = 17$, $S_b(\texttt{babaaa}) = 1+3 = 4$ ⇒ уменьшается

Случай 2: $S_b(l) = S_b(r)$, но $S_a(l) > S_a(r)$

- $\texttt{aaaaa} \to \texttt{a}$: $S_b(\texttt{aaaaa}) = 0$, $S_b(\texttt{a}) = 0$ ⇒ сохраняется, но $S_a(\texttt{aaaaa}) = 1+2+3+4+5 = 15$, $S_a(\texttt{a}) = 1$ ⇒ уменьшается
- $\texttt{bbaaaa} \to \texttt{bb}$: $S_b(\texttt{bbaaaa}) = 1+2 = 3$, $S_b(\texttt{bb}) = 1+2 = 3$ ⇒ сохраняется, но $S_a(\texttt{bbaaaa}) = 3+4+5+6 = 18$, $S_a(\texttt{bb}) = 0$ ⇒ уменьшается

---

### **Итог:**

Для всех правил $l \to r$ выполняется $F(l) > F(r)$ в лексикографическом порядке:

- Либо $S_b(l) > S_b(r)$
- Либо $S_b(l) = S_b(r)$ и $S_a(l) > S_a(r)$

Поскольку значения $S_b$ и $S_a$ ограничены снизу нулём и строго убывают при каждом применении правила, система гарантированно завершается.

Функция $F(w)$ задаёт фундированный порядок, что доказывает **терминируемость** данной SRS.

## 2) Конечность классов эквивалентности по НФ

**Дерево-доказательство.** Построено порождающее дерево слов от ε: рёбра — дописывание `a`|`b`.
Раскраска: зелёные — НФ (ни одно ориентированное правило неприменимо), розовые листья — переписываются в уже встречавшиеся листья и не дают новых НФ.

На внешней границе дерева появляются только розовые листья — новых зелёных узлов нет. Следовательно, множество НФ **конечно**. Фактически получено **54** нормальных форм, значит и число классов эквивалентности по НФ конечно (равно 54).
![Рис. 1. Порождающее дерево слов от ε](img/tree.png)

# 3) Локальная конфлюэнтность

## 3) Локальная конфлюэнтность и пополняемость (Кнут–Бендикс)

### Конфлюэнтность

Так как система **завершаема**, то по **лемме Ньюмана** она будет конфлюэнтна тогда и только тогда, когда она **локально конфлюэнтна**.  
Проверим локальную конфлюэнтность на примере критической пары.

Возьмём слово `bbaaabb`.

1. Если применить правило `baaabb → ε`, получаем:

```
bbaaabb → b
```

2. Если применить правило `bbaaab → aaaab`, получаем:

```
bbaaabb → aaaabb
```

Далее применяем правило `aaaabb → bb`:

```
bbaaabb → aaaabb → bb
```

Получаем две различные нормальные формы: `b` и `bb`.  
Обе являются нормальными формами, следовательно, образуют **критическую пару**, а значит, система **не является локально конфлюэнтной**.

---

### Пополнение по Кнуту–Бендиксу

Так как система не локально конфлюэнтна, применим процедуру **пополнения по Кнуту–Бендиксу**, чтобы устранить конфликты и достичь конфлюэнтности.

---

#### Критическая пара 1

Возьмём базовое слово `baaabb`.

1. Прямое применение правила:

```
baaabb → ε
```

2. Альтернативная редукция:

```
baaabb → baaabaaaa        (по правилу abb → abaaaa)
baaabaaaa → bbbaaaa       (по правилу abaaaa → bba)
bbbaaaa → bbb             (по правилу bbaaaa → bb)
bbb → bab                 (по правилу bbb → bab)
```

Получаем разные нормальные формы: `ε` и `bab`.

Чтобы они сошлись, добавляем новое правило:

```
bab → ε
```

---

#### Последствия добавления `bab → ε`

После добавления этого правила подстрока `bab` становится редуцируемой до ε во всех словах.  
Теперь правила, где `bab` встречается в правой части, становятся глубже сокращаемыми при последующих редукциях, хотя сами правила **формально не изменяются**.

Примерно так теперь редуцируются строки:

```
bbb → bab → ε
abab → bab → ε
bbab → bab → ε
baaaab → bab → ε
babaaba → bab → ε
babaabb → babaaa → aaa
```

---

#### Критическая пара 2

Возьмём базовое слово `bbab`.

1. Первый вариант редукции:

```
bbab → bab → ε (по правилам bbab → bab, а затем bab → ε)
```

2. Второй вариант редукции:

```
bbab → b (по правилу bab → ε)
```

Получаем разные нормальные формы `b` и `ε`.  
Чтобы они сошлись, добавляем новое правило:

```
b → ε
```

---

#### Критическая пара 3

Возьмём базовое слово `abab`.

1. Первый вариант редукции:

```
abab → bab → ε (по правилам abab → bab, а затем bab → ε)
```

2. Второй вариант редукции:

```
abab → a (по правилу bab → ε)
```

Получаем разные нормальные формы `a` и `ε`.  
Чтобы устранить конфликт, добавляем новое правило:

```
a → ε
```

---

### Итоговое пополнение

После последовательного добавления новых правил получаем расширенную систему, в которой каждая строка над алфавитом `{a, b}` редуцируется к пустому слову.

**Добавленные правила:**

```
bab → ε
b → ε
a → ε
```

---

## 4) Минимизация системы

После пополнения любая строка, содержащая символы `a` или `b`, редуцируется до ε.  
Таким образом, единственная нормальная форма — это ε.

Минимальная эквивалентная система переписывания имеет вид:

```text
a → ε
b → ε
```

<img src="img/automaton.png" alt="Рис. 2. Автомат нормальных форм" width="20%">

---

### Итоговые свойства системы

| Свойство                     | Результат             |
| ---------------------------- | --------------------- |
| Завершимость                 | Да                    |
| Локальная конфлюэнтность     | Нет (до пополнения)   |
| Конфлюэнтность               | Да (после пополнения) |
| Пополнение по Кнуту–Бендиксу | Завершено             |
| Конечность классов по НФ     | 1                     |
| Минимальная SRS              | `{ a → ε, b → ε }`    |

---

**Вывод:**
После применения процедуры Кнута–Бендикса система становится завершаемой и конфлюэнтной.
Её минимальная форма состоит из двух простых правил, полностью эквивалентных исходной системе по нормальным формам.

## 5) Инварианты и пересмотр SRS

При наличии правила

```
baaabb → ε
```

все строки переписываются в `ε`, поэтому инварианты становятся **тривиальными** — любые свойства слов (например, количество `a` или `b`) перестают иметь смысл, так как каждая строка сводится к пустому слову.

Чтобы сделать анализ осмысленным, **исключим правило `baaabb → ε`** и рассмотрим изменённую систему.

---

## Исходная система (без `baaabb → ε`)

```text
bbb → bab
abab → bab
abba → aba
babb → abb
bbab → bab
aaaaa → a
aaaba → bba
aaaabb → bb
abb → abaaaa
abaaab → ab
baaaab → bab
bbaaaa → bb
bbaaab → aaaab
baabaab → baaab
babaaba → bab
babaabb → babaaa
```

---

## 5.1) Пополнение по Кнуту–Бендиксу

Так как система не является локально конфлюэнтной, применим процедуру **пополнения по Кнуту–Бендиксу**, чтобы устранить критические пары и добиться конфлюэнтности.

---

### Критическая пара 1

Возьмём слово `abaaaba`.

```
abaaaba → abbba        (по правилу aaaba → bba)
abbba → ababa          (по правилу bbb → bab)
ababa → baba           (по правилу abab → bab)
baba — НФ
```

```
abaaaba → aba          (по правилу abaaab → ab)
aba — НФ
```

Критическая пара: `baba` и `aba`.
Добавляем новое правило:

```
baba → aba
```

---

### Критическая пара 2

Возьмём слово `babaaab`.

```
babaaab → bab          (по правилу abaaab → ab)
bab — НФ
```

```
babaaab → abaaab       (по правилу baba → aba)
abaaab → ab            (по правилу abaaab → ab)
ab — НФ
```

Критическая пара: `bab` и `ab`.
Добавляем новое правило:

```
bab → ab
```

---

### Критическая пара 3

Возьмём слово `baaaabb`.

```
baaaabb → bbb          (по правилу aaaabb → bb)
bbb → bab              (по правилу bbb → bab)
bab → ab               (по правилу bab → ab)
ab — НФ
```

```
baaaabb → babb         (по правилу baaaab → bab)
babb → abb             (по правилу bab → ab)
abb → abaaaa           (по правилу abb → abaaaa)
abaaaa — НФ
```

Критическая пара: `ab` и `abaaaa`.
Добавляем новое правило:

```
abaaaa → ab
```

---

### Критическая пара 4

Возьмём слово `abab`.

```
abab → bab             (по правилу abab → bab)
bab → ab               (по правилу bab → ab)
ab — НФ
```

```
abab → aab             (по правилу bab → ab)
aab — НФ
```

Критическая пара: `aab` и `ab`.
Добавляем новое правило:

```
aab → ab
```

---

### Критическая пара 5

Возьмём слово `aaaabb`.

```
aaaabb → aaabb         (по правилу aab → ab)
aaabb → aabb           (по правилу aab → ab)
aabb → abb             (по правилу aab → ab)
abb → abaaaa           (по правилу abb → abaaaa)
ab — НФ
```

```
aaaabb → bb            (по правилу aaaabb → bb)
bb — НФ
```

Критическая пара: `bb` и `ab`.
Добавляем новое правило:

```
bb → ab
```

---

### Критическая пара 6

Возьмём слово `aabbbbabaabaaaba`.

```
aabbbbabaabaaaba  →  abbbbabaabaaaba        (по правилу aab → ab)
abbbbabaabaaaba  →  abaaaabbabaabaaaba      (по правилу abb → abaaaa)
abaaaabbabaabaaaba  →  abbbabaabaaaba       (по правилу abaaaa → ab)
abbbabaabaaaba  →  abaaaababaabaaaba        (по правилу abb → abaaaa)
abaaaababaabaaaba  →  abbababaabaaaba       (по правилу abaaaa → ab)
abbababaabaaaba  →  ababaabaaaba            (по правилу abba → aba)
ababaabaaaba  →  babaabaaaba                (по правилу abab → bab)
babaabaaaba  →  babaaba                     (по правилу babaaba → bab)
babaaba  →  bab                             (по правилу babaaba → bab)
bab  →  ab                                  (по правилу bab → ab)
ab — НФ
```

```
aabbbbabaabaaaba  →  abbbbabaabaaaba        (по правилу aab → ab)
abbbbabaabaaaba  →  aabbbabaabaaaba         (по правилу bb → ab)
aabbbabaabaaaba  →  abbbabaabaaaba          (по правилу aab → ab)
abbbabaabaaaba  →  aabbabaabaaaba           (по правилу bb → ab)
aabbabaabaaaba  →  abbabaabaaaba            (по правилу aab → ab)
abbabaabaaaba  →  aababaabaaaba             (по правилу bb → ab)
aababaabaaaba  →  ababaabaaaba              (по правилу aab → ab)
ababaabaaaba  →  aabaabaaaba                (по правилу bab → ab)
aabaabaaaba  →  abaabaaaba                  (по правилу aab → ab)
abaabaaaba  →  ababaaaba                    (по правилу aab → ab)
ababaaaba  →  aabaaaba                      (по правилу bab → ab)
aabaaaba  →  abaaaba                        (по правилу aab → ab)
abaaaba  →  abaaba                          (по правилу aab → ab)
abaaba  →  ababa                            (по правилу aab → ab)
ababa  →  aaba                              (по правилу bab → ab)
aaba  →  aba                                (по правилу aab → ab)
aba — НФ
```

Критическая пара: `aba` и `ab`.
Добавляем новое правило:

```
aba → ab
```

---

## Пополненная система

```text
bbb → bab
abab → bab
abba → aba
babb → abb
bbab → bab
aaaaa → a
aaaba → bba
aaaabb → bb
abb → abaaaa
abaaab → ab
baaaab → bab
bbaaaa → bb
bbaaab → aaaab
baabaab → baaab
babaaba → bab
babaabb → babaaa
baba → aba
bab → ab
abaaaa → ab
aab → ab
bb → ab
aba → ab
```

---

## 5.2) Минимизация системы

После пополнения система сводится к компактному виду:
удаляем избыточные и транзитивные правила, оставляя минимальный набор, сохраняющий эквивалентность по нормальным формам.

**Минимальная система переписывания:**

```text
aaaaa → a
aba → ab
aab → ab
bab → ab
bb → ab
```

## <img src="img/automaton_new.png" alt="Рис. 3. Автомат" width="100%">

### Итоговые свойства системы

| Свойство                     | Результат                                      |
| ---------------------------- | ---------------------------------------------- |
| Завершимость                 | Да                                             |
| Локальная конфлюэнтность     | Нет (до пополнения)                            |
| Конфлюэнтность               | Да (после пополнения)                          |
| Пополнение по Кнуту–Бендиксу | Завершено                                      |
| Конечность классов по НФ     | Да                                             |
| Минимальная SRS              | `{ aaaaa→a, aab→ab, bab→ab, bb→ab, aba → ab }` |

---

**Вывод:**
После удаления правила `baaabb → ε` система перестала быть тривиальной.
Пополнение по Кнуту–Бендиксу устранило критические пары, а минимизация привела к компактной конфлюэнтной системе, эквивалентной исходной по нормальным формам.

---

## 5.3) Инварианты

Минимальная система переписывания имеет вид:

```
aaaaa → a
aba   → ab
aab   → ab
bab   → ab
bb    → ab
```

---

## **Инвариант 1: Наличие буквы `b`**

Во всех правилах буква `b` **никогда не исчезает полностью**. Слова, содержащие `b`, не могут перейти в слова без `b`, и наоборот.

**Определение инварианта:**  
`has_b(w) = 1`, если `b` содержится в `w`  
`has_b(w) = 0`, если `b` не содержится в `w`

**Проверка:**

| Правило     | has_b(lhs) | has_b(rhs) | Сохраняется |
| ----------- | ---------- | ---------- | ----------- |
| `aaaaa → a` | 0          | 0          | ✓           |
| `aba → ab`  | 1          | 1          | ✓           |
| `aab → ab`  | 1          | 1          | ✓           |
| `bab → ab`  | 1          | 1          | ✓           |
| `bb → ab`   | 1          | 1          | ✓           |

✅ Инвариант выполняется для всех правил.

---

## **Инвариант 2: Остаток числа `a` по модулю 4 (для слов без `b`)**

Если слово **не содержит буквы `b`**, то к нему применимо только одно правило:

```
aaaaa → a
```

Это правило уменьшает число `a` на 4, поэтому сохраняется остаток по модулю 4.

**Определение инварианта:**  
`Φₐ(w) = количество_а(w) mod 4`, если `b` не содержится в `w`  
`Φₐ(w) = не определено`, если `b` содержится в `w`

**Проверка:**  
`Φₐ("aaaaa") = 5 mod 4 = 1`  
`Φₐ("a") = 1 mod 4 = 1`

✅ Инвариант сохраняется.

---

## **Инвариант 3: Нормальная форма слов, оканчивающихся на `b`**

Любое слово длиной ≥ 2, которое заканчивается на `b`, обязательно содержит одну из подстрок:

- `bb` → `ab`
- `bab` → `ab`
- `aab` → `ab`

и каждая из них **редуцируется в `ab`**.

Поэтому независимо от окружения конечный `b` "проталкивается" к редукции, и нормальная форма всегда:

`NF(w) = "ab"`, если `|w| ≥ 2` и последний символ `w` = `b`

**Определение инварианта:**  
`end_b_nf(w) = "ab"`, если `|w| ≥ 2` и последний символ = `b`  
`end_b_nf(w) = не определено`, иначе

✅ Таким образом, все длинные слова вида `...b` в минимальной SRS сводятся строго к `ab`.

---

## **Сводный инвариант**

`Inv(w) = (has_b(w), Φₐ(w), end_b_nf(w))`

---

## **Вывод**

Минимальная система обладает следующими устойчивыми свойствами:

1. **Наличие буквы `b`** никогда не исчезает при редукциях
2. Для слов без `b` сохраняется **остаток числа `a` по модулю 4**
3. Любое слово длиной ≥ 2, **оканчивающееся на `b`**, имеет нормальную форму **`ab`**

Эти инварианты полностью согласуются со структурой минимальной системы и корректно описывают её поведение.

---
